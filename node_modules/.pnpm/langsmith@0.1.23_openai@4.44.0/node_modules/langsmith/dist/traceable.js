import { AsyncLocalStorage } from "async_hooks";
import { RunTree, isRunTree, isRunnableConfigLike, } from "./run_trees.js";
import { getEnvironmentVariable } from "./utils/env.js";
function isPromiseMethod(x) {
    if (x === "then" || x === "catch" || x === "finally") {
        return true;
    }
    return false;
}
const asyncLocalStorage = new AsyncLocalStorage();
export const ROOT = Symbol("langsmith:traceable:root");
const isAsyncIterable = (x) => x != null &&
    typeof x === "object" &&
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof x[Symbol.asyncIterator] === "function";
const tracingIsEnabled = (tracingEnabled) => {
    if (tracingEnabled !== undefined) {
        return tracingEnabled;
    }
    const envVars = [
        "LANGSMITH_TRACING_V2",
        "LANGCHAIN_TRACING_V2",
        "LANGSMITH_TRACING",
        "LANGCHAIN_TRACING",
    ];
    return Boolean(envVars.find((envVar) => getEnvironmentVariable(envVar) === "true"));
};
const handleRunInputs = (rawInputs) => {
    const firstInput = rawInputs[0];
    if (firstInput == null) {
        return {};
    }
    if (rawInputs.length > 1) {
        return { args: rawInputs };
    }
    if (isKVMap(firstInput)) {
        return firstInput;
    }
    return { input: firstInput };
};
const handleRunOutputs = (rawOutputs) => {
    if (isKVMap(rawOutputs)) {
        return rawOutputs;
    }
    return { outputs: rawOutputs };
};
const getTracingRunTree = (runTree, inputs) => {
    const tracingEnabled_ = tracingIsEnabled(runTree.tracingEnabled);
    if (!tracingEnabled_) {
        return undefined;
    }
    runTree.inputs = handleRunInputs(inputs);
    return runTree;
};
/**
 * Higher-order function that takes function as input and returns a
 * "TraceableFunction" - a wrapped version of the input that
 * automatically handles tracing. If the returned traceable function calls any
 * traceable functions, those are automatically traced as well.
 *
 * The returned TraceableFunction can accept a run tree or run tree config as
 * its first argument. If omitted, it will default to the caller's run tree,
 * or will be treated as a root run.
 *
 * @param wrappedFunc Targeted function to be traced
 * @param config Additional metadata such as name, tags or providing
 *     a custom LangSmith client instance
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function traceable(wrappedFunc, config) {
    const { aggregator, argsConfigPath, ...runTreeConfig } = config ?? {};
    const traceableFunc = (...args) => {
        let ensuredConfig;
        try {
            let runtimeConfig;
            if (argsConfigPath) {
                const [index, path] = argsConfigPath;
                if (index === args.length - 1 && !path) {
                    runtimeConfig = args.pop();
                }
                else if (index <= args.length &&
                    typeof args[index] === "object" &&
                    args[index] !== null) {
                    if (path) {
                        const { [path]: extracted, ...rest } = args[index];
                        runtimeConfig = extracted;
                        args[index] = rest;
                    }
                    else {
                        runtimeConfig = args[index];
                        args.splice(index, 1);
                    }
                }
            }
            ensuredConfig = {
                name: wrappedFunc.name || "<lambda>",
                ...runTreeConfig,
                ...runtimeConfig,
                tags: [
                    ...new Set([
                        ...(runTreeConfig?.tags ?? []),
                        ...(runtimeConfig?.tags ?? []),
                    ]),
                ],
                metadata: {
                    ...runTreeConfig?.metadata,
                    ...runtimeConfig?.metadata,
                },
            };
        }
        catch (err) {
            console.warn(`Failed to extract runtime config from args for ${runTreeConfig?.name ?? wrappedFunc.name}`, err);
            ensuredConfig = {
                name: wrappedFunc.name || "<lambda>",
                ...runTreeConfig,
            };
        }
        const [currentRunTree, rawInputs] = (() => {
            const [firstArg, ...restArgs] = args;
            // used for handoff between LangChain.JS and traceable functions
            if (isRunnableConfigLike(firstArg)) {
                return [
                    getTracingRunTree(RunTree.fromRunnableConfig(firstArg, ensuredConfig), restArgs),
                    restArgs,
                ];
            }
            // legacy CallbackManagerRunTree used in runOnDataset
            // override ALS and do not pass-through the run tree
            if (isRunTree(firstArg) &&
                "callbackManager" in firstArg &&
                firstArg.callbackManager != null) {
                return [firstArg, restArgs];
            }
            // when ALS is unreliable, users can manually
            // pass in the run tree
            if (firstArg === ROOT || isRunTree(firstArg)) {
                const currentRunTree = getTracingRunTree(firstArg === ROOT
                    ? new RunTree(ensuredConfig)
                    : firstArg.createChild(ensuredConfig), restArgs);
                return [currentRunTree, [currentRunTree, ...restArgs]];
            }
            // Node.JS uses AsyncLocalStorage (ALS) and AsyncResource
            // to allow storing context
            const prevRunFromStore = asyncLocalStorage.getStore();
            if (prevRunFromStore) {
                return [
                    getTracingRunTree(prevRunFromStore.createChild(ensuredConfig), args),
                    args,
                ];
            }
            const currentRunTree = getTracingRunTree(new RunTree(ensuredConfig), args);
            return [currentRunTree, args];
        })();
        return asyncLocalStorage.run(currentRunTree, () => {
            const postRunPromise = currentRunTree?.postRun();
            async function handleChunks(chunks) {
                if (aggregator !== undefined) {
                    try {
                        return await aggregator(chunks);
                    }
                    catch (e) {
                        console.error(`[ERROR]: LangSmith aggregation failed: `, e);
                    }
                }
                return chunks;
            }
            async function* wrapAsyncGeneratorForTracing(iterable, snapshot) {
                let finished = false;
                const chunks = [];
                try {
                    const iterator = iterable[Symbol.asyncIterator]();
                    while (true) {
                        const { value, done } = await (snapshot
                            ? snapshot(() => iterator.next())
                            : iterator.next());
                        if (done) {
                            finished = true;
                            break;
                        }
                        chunks.push(value);
                        yield value;
                    }
                }
                catch (e) {
                    await currentRunTree?.end(undefined, String(e));
                    throw e;
                }
                finally {
                    if (!finished)
                        await currentRunTree?.end(undefined, "Cancelled");
                    await currentRunTree?.end(handleRunOutputs(await handleChunks(chunks)));
                    await handleEnd();
                }
            }
            async function handleEnd() {
                const onEnd = config?.on_end;
                if (onEnd) {
                    if (!currentRunTree) {
                        console.warn("Can not call 'on_end' if currentRunTree is undefined");
                    }
                    else {
                        onEnd(currentRunTree);
                    }
                }
                await postRunPromise;
                await currentRunTree?.patchRun();
            }
            let returnValue;
            try {
                returnValue = wrappedFunc(...rawInputs);
            }
            catch (err) {
                returnValue = Promise.reject(err);
            }
            if (isAsyncIterable(returnValue)) {
                const snapshot = AsyncLocalStorage.snapshot();
                return wrapAsyncGeneratorForTracing(returnValue, snapshot);
            }
            const tracedPromise = new Promise((resolve, reject) => {
                Promise.resolve(returnValue)
                    .then(async (rawOutput) => {
                    if (isAsyncIterable(rawOutput)) {
                        const snapshot = AsyncLocalStorage.snapshot();
                        return resolve(wrapAsyncGeneratorForTracing(rawOutput, snapshot));
                    }
                    else {
                        try {
                            await currentRunTree?.end(handleRunOutputs(rawOutput));
                            await handleEnd();
                        }
                        finally {
                            // eslint-disable-next-line no-unsafe-finally
                            return rawOutput;
                        }
                    }
                }, async (error) => {
                    await currentRunTree?.end(undefined, String(error));
                    await handleEnd();
                    throw error;
                })
                    .then(resolve, reject);
            });
            if (typeof returnValue !== "object" || returnValue === null) {
                return tracedPromise;
            }
            return new Proxy(returnValue, {
                get(target, prop, receiver) {
                    if (isPromiseMethod(prop)) {
                        return tracedPromise[prop].bind(tracedPromise);
                    }
                    return Reflect.get(target, prop, receiver);
                },
            });
        });
    };
    Object.defineProperty(traceableFunc, "langsmith:traceable", {
        value: runTreeConfig,
    });
    return traceableFunc;
}
/**
 * Return the current run tree from within a traceable-wrapped function.
 * Will throw an error if called outside of a traceable function.
 *
 * @returns The run tree for the given context.
 */
export function getCurrentRunTree() {
    const runTree = asyncLocalStorage.getStore();
    if (runTree === undefined) {
        throw new Error([
            "Could not get the current run tree.",
            "",
            "Please make sure you are calling this method within a traceable function.",
        ].join("\n"));
    }
    return runTree;
}
export function isTraceableFunction(x
// eslint-disable-next-line @typescript-eslint/no-explicit-any
) {
    return typeof x === "function" && "langsmith:traceable" in x;
}
function isKVMap(x) {
    return (typeof x === "object" &&
        x != null &&
        !Array.isArray(x) &&
        // eslint-disable-next-line no-instanceof/no-instanceof
        !(x instanceof Date));
}
export function wrapFunctionAndEnsureTraceable(target, options, name = "target") {
    if (typeof target === "function") {
        return traceable(target, {
            ...options,
            name,
        });
    }
    throw new Error("Target must be runnable function");
}
